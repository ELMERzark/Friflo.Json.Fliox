// Copyright (c) Ullrich Praetz. All rights reserved.
// See LICENSE file in the project root for full license information.
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.CompilerServices;
using Friflo.Json.Mapper.Map.Utils;
using Friflo.Json.Mapper.Utils;

namespace Friflo.Json.Mapper.Map.Obj.Reflect
{
    public class  FieldQuery
    {
        internal readonly   List<PropField>     fieldList = new List <PropField>();
        internal            int                 primCount;
        internal            int                 objCount;
        private  readonly   TypeStore           typeStore;

        internal FieldQuery(TypeStore typeStore, Type type) {
            this.typeStore = typeStore;
            TraverseMembers(type, true);
        }

        private void CreatePropField (Type type, string fieldName, PropertyInfo property, FieldInfo field, bool addMembers) {
            // getter have higher priority than fields with the same fieldName. Same behavior as other serialization libs
            Type            memberType;
            string          jsonName;
            if (property != null) {
                memberType   = property.PropertyType;
                jsonName = GetPropertyName(property.CustomAttributes);

            } else {
                memberType   = field.FieldType;
                jsonName = GetPropertyName(field.CustomAttributes);
            }
            if (memberType == null)
                throw new InvalidOperationException("Field '" + fieldName + "' ('" + fieldName + "') not found in type " + type);

            TypeMapper  mapper      = typeStore.GetTypeMapper(memberType);
            Type        ut          = mapper.nullableUnderlyingType;
            bool isNullablePrimitive = ut != null && ut.IsPrimitive;
            bool isNullableEnum      = ut != null && ut.IsEnum;
            
            if (addMembers) {
                if (jsonName == null)
                    jsonName = typeStore.config.jsonNaming.PropertyName(fieldName);
                
                PropField pf;
                if (memberType.IsEnum || memberType.IsPrimitive || isNullablePrimitive || isNullableEnum) {
                    pf =     new PropField(fieldName, jsonName, mapper, field, property, primCount,    -9999); // force index exception in case of buggy impl.
                } else {
                    if (mapper.isValueType)
                        pf = new PropField(fieldName, jsonName, mapper, field, property, primCount, objCount);
                    else
                        pf = new PropField(fieldName, jsonName, mapper, field, property, -9999,     objCount); // force index exception in case of buggy impl.
                }

                fieldList.Add(pf);
            }
            
            if (memberType.IsPrimitive || isNullablePrimitive || memberType.IsEnum || isNullableEnum) {
                primCount++;
            } else if (mapper.isValueType) {
                // struct itself must not be incremented only its members. Their position need to be counted 
                TraverseMembers(mapper.type, false);
            } else
                objCount++; // object
        }

        private void TraverseMembers(Type type, bool addMembers) {
            Type nullableStruct = TypeUtils.GetNullableStruct(type);
            if (nullableStruct != null) {
                type = nullableStruct;
                primCount++;  // require array element to represent if Nullable<struct> is null or set (1) 
            }

            BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;

            PropertyInfo[] properties = type.GetProperties(flags);
            for (int n = 0; n < properties.Length; n++) {
                var property = properties[n];
                if (!(property.CanRead && property.CanWrite))
                    continue;
                // Is getter and setter public?
                bool isPublic = property.GetGetMethod(false) != null && property.GetSetMethod(false) != null;
                if (!isPublic && !GetProperty(property.CustomAttributes))
                    continue;
                var name = property.Name;
                CreatePropField(type, name, property, null, addMembers);
            }

            FieldInfo[] fields = type.GetFields(flags);
            for (int n = 0; n < fields.Length; n++) {
                var field = fields[n];
                if (IsAutoGeneratedBackingField(field))
                    continue;
                if (!field.IsPublic && !GetProperty(field.CustomAttributes))
                    continue;
                var name = field.Name;
                CreatePropField(type, name, null, field, addMembers);
            }
        }

        private static bool IsAutoGeneratedBackingField(FieldInfo field) {
            foreach (CustomAttributeData attr in field.CustomAttributes) {
                if (attr.AttributeType == typeof(CompilerGeneratedAttribute))
                    return true;
            }
            return false;
        }
        
        private static bool GetProperty(IEnumerable<CustomAttributeData> attributes) {
            foreach (var attr in attributes) {
                if (attr.AttributeType == typeof(FloPropertyAttribute))
                    return true;
            }
            return false;
        }
                
        private static string GetPropertyName(IEnumerable<CustomAttributeData> attributes) {
            foreach (var attr in attributes) {
                if (attr.AttributeType == typeof(FloPropertyAttribute)) {
                    if (attr.NamedArguments != null) {
                        foreach (var args in attr.NamedArguments) {
                            if (args.MemberName == nameof(FloPropertyAttribute.Name)) {
                                if (args.TypedValue.Value != null)
                                    return args.TypedValue.Value as string;
                            }
                        }
                    }
                }
            }
            return null;
        }
    }
}
