// Copyright (c) Ullrich Praetz. All rights reserved.
// See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.CompilerServices;
using Friflo.Json.Fliox.Mapper;
using Friflo.Json.Fliox.Mapper.Utils;

namespace Friflo.Json.Fliox.Hub.Client.Internal.Map
{
    internal static class ClientEntityUtils
    {
        private static readonly Dictionary<Type, EntityInfo[]>     EntityInfoCache      = new Dictionary<Type, EntityInfo[]>();
        private static readonly Dictionary<Type, IEntitySetMapper> EntitySetMapperCache = new Dictionary<Type, IEntitySetMapper>();
        
        private static readonly StoreConfig DefaultStoreConfig = new StoreConfig();
        
        private static IEntitySetMapper GetEntitySetMapper(Type type) {
            var cache = EntitySetMapperCache;
            if (cache.TryGetValue(type, out var mapper)) {
                return mapper;
            }
            mapper = (IEntitySetMapper)EntitySetMatcher.CreateMapper(type, DefaultStoreConfig);
            cache[type] = mapper;
            return mapper;
        }
        
        internal static EntityInfo[] GetEntityInfos(Type client) {
            var cache = EntityInfoCache;
            lock (cache) {
                if (cache.TryGetValue(client, out  EntityInfo[] result)) {
                    return result;
                }
                var entityInfos = new List<EntityInfo>();
                var flags       = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
                PropertyInfo[] properties = client.GetProperties(flags);
                for (int n = 0; n < properties.Length; n++) {
                    var  property       = properties[n];
                    Type propType       = property.PropertyType;
                    bool isEntitySet    = IsEntitySet(propType);
                    if (!isEntitySet)
                        continue;
                    var mapper      = GetEntitySetMapper(propType);
                    var genericArgs = propType.GetGenericArguments();
                    var info        = new EntityInfo (property.Name, propType, genericArgs[0], genericArgs[1], client, mapper, property );
                    entityInfos.Add(info);
                }
                FieldInfo[] fields = client.GetFields(flags);
                for (int n = 0; n < fields.Length; n++) {
                    var  field          = fields[n];
                    Type fieldType      = field.FieldType;
                    bool isEntitySet    = IsEntitySet(fieldType);
                    if (!isEntitySet || IsAutoGeneratedBackingField(field))
                        continue;
                    var mapper      = GetEntitySetMapper(fieldType);
                    var genericArgs = fieldType.GetGenericArguments();
                    var info        = new EntityInfo (field.Name, fieldType, genericArgs[0], genericArgs[1], client, mapper, field);
                    entityInfos.Add(info);
                }
                result = entityInfos.ToArray();
                cache.Add(client, result);
                return result;
            }
        }
        
        internal static Type[] GetEntityTypes(Type clientType) {
            var entityInfos = GetEntityInfos (clientType);
            var types       = new Type[entityInfos.Length];
            for (int n = 0; n < entityInfos.Length; n++) {
                types[n] = entityInfos[n].entityType;
            }
            return  types;
        }

        internal static bool IsEntitySet (Type type) {
            return type.IsGenericType && type.GetGenericTypeDefinition() == typeof(EntitySet<,>);
        }
        
        private static bool IsAutoGeneratedBackingField(FieldInfo field) {
            foreach (CustomAttributeData attr in field.CustomAttributes) {
                if (attr.AttributeType == typeof(CompilerGeneratedAttribute))
                    return true;
            }
            return false;
        }
    }
    
    internal readonly struct EntityInfo
    {
        internal readonly   string              container;
        internal readonly   ShortString         containerShort;
        internal readonly   Type                entitySetType;
        internal readonly   Type                keyType;
        internal readonly   Type                entityType;
        internal readonly   IContainerMember    containerMember;

        public   override   string              ToString() => container;

        internal EntityInfo (
            string              container,
            Type                entitySetType,
            Type                keyType,
            Type                entityType,
            Type                client,
            IEntitySetMapper    mapper,
            MemberInfo          member)
        {
            containerMember     = mapper.CreateContainerMember(client, container);
            AttributeUtils.Property(member.CustomAttributes, out string name);
            this.container      = name ?? container;
            this.containerShort = new ShortString(this.container);
            this.entitySetType  = entitySetType;
            this.keyType        = keyType;
            this.entityType     = entityType;
        }
    }
}