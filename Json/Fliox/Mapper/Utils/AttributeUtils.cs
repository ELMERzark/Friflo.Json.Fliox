// Copyright (c) Ullrich Praetz. All rights reserved.
// See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using System.Runtime.CompilerServices;

namespace Friflo.Json.Fliox.Mapper.Utils
{
    public static class AttributeUtils {
                
        public static void Property(IEnumerable<CustomAttributeData> attributes, out string name) {
            name        = null;
            foreach (var attr in attributes) {
                if (attr.AttributeType != typeof(SerializeAttribute))
                    continue;
                var arguments   = attr.ConstructorArguments;
                name = arguments.Count < 1 ? null : (string)arguments[0].Value;
            }
        }
        
        public static string CommandName(IEnumerable<CustomAttributeData> attributes) {
            foreach (var attr in attributes) {
                if (attr.AttributeType != typeof(DatabaseCommandAttribute))
                    continue;
                var arguments   = attr.ConstructorArguments;
                return arguments.Count < 1 ? null : (string)arguments[0].Value;
            }
            return null;
        }
        
        public static HandlerType GetHandler(IEnumerable<CustomAttributeData> attributes, out string name) {
            foreach (var attr in attributes) {
                var type = GetHandlerType (attr.AttributeType);
                if (type == HandlerType.None) {
                    continue;
                }
                var arguments   = attr.ConstructorArguments;
                name =  arguments.Count < 1 ? null : (string)arguments[0].Value;
                return type;
            }
            name = null;
            return HandlerType.None;
        }
        
        private static HandlerType GetHandlerType(Type type) {
            if (type == typeof(CommandHandlerAttribute)) {
                return HandlerType.CommandHandler;
            }
            if (type == typeof(MessageHandlerAttribute)) {
                return HandlerType.MessageHandler;
            }
            return HandlerType.None;
        }
        
        internal static void GetMembers(Type type, List<MemberInfo> members) {
            if (type == null || type == typeof(object))
                return;
            var baseType = type.BaseType;
            GetMembers(baseType, members);
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly;
            var memberInfos = type.GetMembers(flags);
            foreach (var member in memberInfos) {
                switch (member) {
                    case PropertyInfo _:
                    case FieldInfo _:
                        members.Add(member);
                        break;
                }
            }
        }

        internal static bool IsAutoGeneratedBackingField(FieldInfo field) {
            foreach (CustomAttributeData attr in field.CustomAttributes) {
                if (attr.AttributeType == typeof(CompilerGeneratedAttribute))
                    return true;
            }
            return false;
        }
        
        public static bool Property(IEnumerable<CustomAttributeData> attributes) {
            foreach (var attr in attributes) {
                if (attr.AttributeType == typeof(SerializeAttribute))
                    return true;
            }
            return false;
        }
        
        internal static bool Ignore(IEnumerable<CustomAttributeData> attributes) {
            foreach (var attr in attributes) {
                if (attr.AttributeType == typeof(IgnoreAttribute))
                    return true;
            }
            return false;
        }

        internal static bool IsRequired(IEnumerable<CustomAttributeData> attributes) {
            foreach (var attr in attributes) {
                if (attr.AttributeType == typeof(RequiredAttribute))
                    return true;
                if (attr.AttributeType == typeof(KeyAttribute))
                    return true;
                // Unity has System.ComponentModel.DataAnnotations.KeyAttribute no available by default
                if (attr.AttributeType.FullName == "System.ComponentModel.DataAnnotations.RequiredAttribute")
                    return true;
            }
            return false;
        }
        
        public static bool IsKey(IEnumerable<CustomAttributeData> attributes) {
            foreach (var attr in attributes) {
                /* if (attr.AttributeType == typeof(PrimaryKeyAttribute))
                    return true; */
                // Unity has System.ComponentModel.DataAnnotations.KeyAttribute no available by default
                if (attr.AttributeType == typeof(KeyAttribute))
                    return true;
            }
            return false;
        }
        
        public static bool IsAutoIncrement(IEnumerable<CustomAttributeData> attributes) {
            foreach (var attr in attributes) {
                if (attr.AttributeType == typeof(AutoIncrementAttribute))
                    return true;
            }
            return false;
        }
        
        public static bool JsonNamingType(IEnumerable<CustomAttributeData> attributes, out JsonNamingType type) {
            foreach (var attr in attributes) {
                if (attr.AttributeType == typeof(JsonNamingAttribute)) {
                    var arguments   = attr.ConstructorArguments;
                    type = (JsonNamingType)arguments[0].Value;
                    return true;
                }
            }
            type = default;
            return false;
        }
    }
            
    public enum HandlerType
    {
        None            = 0,
        MessageHandler  = 1,
        CommandHandler  = 2,
    }
}